"""
IGC telemetry stream extraction — this module parses the IGC telemetry track generated by Seeyou Navigator.

For IGC file, parse the plain-text IGC records and produce two output files.

1. `{flight_tag}_igc_meta.json` — flight metadata (§3.5)
2. `{flight_tag}_igc.csv` — 1 Hz trajectory CSV (§3.3)

See `extract_igc_streams.py` for detailed documentation.

#### 3.1 IGC format overview

The IGC (International Gliding Commission) file format is a plain-text standard for GNSS flight recorders. Each line starts with a single uppercase letter identifying the record type. The records relevant to extraction are:

| Record | Description | Cardinality |
|--------|-------------|-------------|
| **A** | Flight recorder manufacturer and serial | single |
| **H** | Header — date, pilot, glider, hardware, etc. | single (multi-line) |
| **I** | Defines extension fields appended to each B record | single |
| **J** | Defines extension fields in K records | single |
| **B** | Fix — UTC time, lat, lon, pressure alt, GNSS alt, validity, extensions | multiple (~1 Hz) |
| **K** | Less-frequent extension data (e.g. wind from SeeYou) | multiple |
| **E** | Events (altimeter setting changes, pilot events) | multiple |
| **L** | Comments / logbook (includes SeeYou phase annotations) | multiple |
| **G** | Security signature | single (last) |

Our IGC files are produced by **SeeYou Navigator** running on a smartphone. Key characteristics:

- **No pressure altitude sensor** — `HFPRSPRESSALTSENSOR:NIL`. The pressure altitude field in B records is always `00000`.
- **GPS altitude reference** — `HFALGALTGPS:ELL` means altitude is above the WGS 84 ellipsoid (not the geoid).
- **Fix rate** — 1 Hz (one B record per second).
- **K records** — contain wind direction (`WDI`) and wind speed (`WSP`) from SeeYou's internal estimation. Currently observed as sentinel values (`999` for speed); not extracted.
- **L records** — contain SeeYou phase annotations (`onGround`, `takingOff`, `flying`, `landing`, etc.) and post-flight statistics. Not extracted in this step.

#### 3.2 Parsing

The parser is implemented without external libraries (the IGC text format is simple enough to parse directly, consistent with the GPMF parser in step 2). Parsing proceeds in a single pass over the file lines:

1. **H records** → extract metadata key-value pairs. The H record subtypes are identified by their three-letter code (TLC) after the source byte (`F`, `O`, or `P`). We handle both the legacy format (`HFDTEDDMMYY`) and the newer format with a long name and colon (`HFDTEDATE:DDMMYY`).
2. **I record** → parse extension definitions to know byte positions of any additional fields in B records. Store as a list of `(start_byte, end_byte, TLC)` tuples (1-based byte positions).
3. **B records** → parse each fix into structured data. The B record format (first 35 bytes) is fixed:

   ```
   B HHMMSS DDMMmmmN/S DDDMMmmmE/W V PPPPP GGGGG [extensions...]
   ```

   - Time: `HHMMSS` (UTC). Combined with the date from `HFDTE` to form an absolute timestamp.
   - Latitude: `DDMMmmmN/S` → decimal degrees (positive = North).
   - Longitude: `DDDMMmmmE/W` → decimal degrees (positive = East).
   - Fix validity: `A` (3D fix, valid) or `V` (2D or no GPS).
   - Pressure altitude: `PPPPP` (meters above ISA 1013.25 hPa sea-level datum). Can be negative (prefix `-`).
   - GNSS altitude: `GGGGG` (meters above WGS 84 ellipsoid or geoid, per `HFALG`).

4. **Midnight rollover** — if B-record times decrease (e.g. `235959` → `000001`), the date is advanced by one day.

#### 3.3 Output: 1 Hz trajectory CSV

Output path: `config.DIR.TELEMETRY / f"{flight_tag}_igc.csv"`

One row per B record (~1 Hz). Column naming follows the MP4 CSV conventions where applicable so that downstream steps (4–6) can consume both CSV types uniformly.

| Column | Source | Units | Description |
|--------|--------|-------|-------------|
| `timestamp_s` | B-record time | s | Seconds since the first B-record fix. Float. |
| `gps_lat_deg` | B-record lat | deg | Latitude WGS 84, decimal degrees (positive N) |
| `gps_lon_deg` | B-record lon | deg | Longitude WGS 84, decimal degrees (positive E) |
| `alt_baro_m` | B-record PPPPP | m | Pressure altitude (ISA 1013.25 hPa). 0 when sensor not available. |
| `alt_gps_m` | B-record GGGGG | m | GNSS altitude (ellipsoid or geoid per `HFALG`) |
| `fix_validity` | B-record V flag | — | `A` (3D valid) or `V` (2D / no GPS) |

The `timestamp_s` column contains seconds since the first B-record; to obtain absolute UTC times, use `gps_start_utc` from the metadata JSON (§3.5).

> **Note on altitude columns:** The MP4 CSV has a single `gps_alt_m` column (WGS 84 GPS altitude from the GoPro). The IGC format natively provides two altitude references — barometric and GNSS — so both are preserved. When the pressure sensor is absent (`HFPRSPRESSALTSENSOR:NIL`), `alt_baro_m` will be 0 for every row; downstream steps should check the `pressure_sensor` metadata field before using this column.

#### 3.4 Data not extracted

The following IGC data is **not** extracted in this step:

- **K records** (wind direction/speed) — SeeYou Navigator fills these with sentinel/placeholder values. If future IGC sources provide reliable K-record data, extraction can be added.
- **L records** (SeeYou phase annotations, post-flight statistics) — app-specific; not needed for trajectory reconstruction.
- **E records** (events) — altimeter setting changes and pilot events; not needed for trajectory reconstruction.
- **C records** (task declarations) — competition task waypoints; not relevant to visualization.
- **I-record extensions** beyond the base 35 bytes — e.g. FXA (fix accuracy), SIU (satellites in use), ENL (engine noise). These could be extracted in the future if present and useful; for now the base B-record fields are sufficient.

#### 3.5 Output: flight metadata JSON

Output path: `config.DIR.TELEMETRY / f"{flight_tag}_igc_meta.json"`

Contains recording-level metadata extracted from H records and derived from B records. Follows the spirit of the MP4 metadata JSON (§2.5) but reflects IGC-specific fields.

| Key | H-record TLC | Example | Description |
|-----|-------------|---------|-------------|
| `date` | `DTE` | `"2025-05-08"` | UTC date of the flight (ISO 8601) |
| `gps_start_utc` | derived | `"2025-05-08T10:48:23Z"` | ISO 8601 UTC timestamp of the first B-record fix |
| `duration_s` | derived | `392.0` | Seconds from first to last B-record fix |
| `num_fixes` | derived | `393` | Total number of B records |
| `pilot` | `PLT` | `"Andrzej Nagorko"` | Pilot in charge |
| `copilot` | `CM2` | `null` | Second crew member (null if `NIL`) |
| `glider_type` | `GTY` | `"SZD 51-1 Junior"` | Glider model |
| `glider_id` | `GID` | `"SP-3303"` | Glider registration |
| `competition_id` | `CID` | `"LK"` | Competition / fin ID |
| `competition_class` | `CCL` | `"NKN"` | Competition class |
| `fr_type` | `FTY` | `"Naviter,SeeYou Navigator"` | Flight recorder manufacturer and model |
| `firmware` | `RFW` | `"3.4.0+2662"` | Firmware / app version |
| `hardware` | `RHW` | `"Samsung SM-A356B,Android 14"` | Hardware description |
| `gps_receiver` | `GPS` | `"Internal sensors,Internal,0,0"` | GPS receiver info |
| `pressure_sensor` | `PRS` | `"NIL"` | Pressure altitude sensor (`"NIL"` = not available) |
| `gps_datum` | `DTM` | `"WGS84"` | Geodetic datum |
| `altitude_gps_ref` | `ALG` | `"ELL"` | GPS altitude reference: `ELL` (ellipsoid) or `GEO` (geoid) |
| `altitude_pressure_ref` | `ALP` | `"NIL"` | Pressure altitude reference (or `"NIL"`) |
| `timezone_offset_h` | `TZN` | `2.0` | Hours from UTC to local time (or null) |
| `fr_id` | A record | `"XNA8C5088BE0F07DB0D41D9BACBE74EEF03"` | Flight recorder manufacturer code and serial |

#### 3.6 Implementation notes

- **No external dependencies.** The parser uses only the Python standard library and numpy/pandas (already project dependencies). The IGC format is a simple line-oriented text protocol — unlike GPMF binary parsing, no struct unpacking or atom traversal is needed.
- **Function signature** follows the step 2 pattern: `extract_igc_telemetry(flight_data: FlightData) -> FlightData`. The function reads `flight_data.igc_path`, writes output files to `config.DIR.TELEMETRY`, and returns an updated `FlightData` with the new file paths populated.
- **Logging** follows the step 2 pattern: log file sizes, row counts, time span, coordinate ranges, and fix validity statistics.
- **`FlightData` model update:** Add an `igc_trajectory` field (path to the CSV) and an `igc_metadata` field (path to the JSON), mirroring the `MP4Telemetry` structure.

"""

from __future__ import annotations

import json
import logging
import time
from datetime import date, datetime, timedelta, timezone
from pathlib import Path
from typing import Any

import pandas as pd

from flight_composer.config import config
from flight_composer.processing.flight_data import (
    FlightData,
    IGCTelemetry,
    WGS84Coordinate,
)

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# H-record three-letter code → metadata JSON key
# ---------------------------------------------------------------------------
_H_TLC_MAP: dict[str, str] = {
    "PLT": "pilot",
    "CM2": "copilot",
    "GTY": "glider_type",
    "GID": "glider_id",
    "CID": "competition_id",
    "CCL": "competition_class",
    "FTY": "fr_type",
    "RFW": "firmware",
    "RHW": "hardware",
    "GPS": "gps_receiver",
    "PRS": "pressure_sensor",
    "DTM": "gps_datum",
    "ALG": "altitude_gps_ref",
    "ALP": "altitude_pressure_ref",
    "TZN": "timezone_offset_h",
}


# ---------------------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------------------


def _parse_igc_latitude(raw: str) -> float:
    """Convert IGC latitude ``DDMMmmmN`` (8 chars) to decimal degrees.

    The format is ``DDMMmmmH`` where DD = degrees, MM = whole minutes,
    mmm = fractional minutes (thousandths), and H = hemisphere (N/S).
    """
    dd = int(raw[0:2])
    mm_mmm = int(raw[2:7])  # MMmmm as an integer
    hemisphere = raw[7]
    decimal_deg = dd + mm_mmm / 60_000.0
    if hemisphere == "S":
        decimal_deg = -decimal_deg
    return decimal_deg


def _parse_igc_longitude(raw: str) -> float:
    """Convert IGC longitude ``DDDMMmmmE`` (9 chars) to decimal degrees.

    The format is ``DDDMMmmmH`` where DDD = degrees, MM = whole minutes,
    mmm = fractional minutes (thousandths), and H = hemisphere (E/W).
    """
    ddd = int(raw[0:3])
    mm_mmm = int(raw[3:8])  # MMmmm as an integer
    hemisphere = raw[8]
    decimal_deg = ddd + mm_mmm / 60_000.0
    if hemisphere == "W":
        decimal_deg = -decimal_deg
    return decimal_deg


def _parse_hfdte(value: str) -> date:
    """Parse the DTE value ``DDMMYY`` (with optional ``,NN`` flight
    number suffix).

       The IGC spec uses a two-digit year; we assume 2000+ for YY < 80.
    """
    # Strip optional flight-number suffix (e.g. "080525,01" → "080525")
    ddmmyy = value.split(",")[0].strip()
    dd = int(ddmmyy[0:2])
    mm = int(ddmmyy[2:4])
    yy = int(ddmmyy[4:6])
    year = 2000 + yy if yy < 80 else 1900 + yy
    return date(year, mm, dd)


def _parse_h_record(line: str) -> tuple[str, str]:
    """Return ``(TLC, value)`` from an H record line.

    Handles both legacy (``HFDTEDDMMYY``) and newer
    (``HFDTEDATE:DDMMYY,01``) formats.

    The *source byte* at position 1 (``F``, ``O``, or ``P``) is skipped.
    The TLC occupies positions 2–4 (inclusive).
    """
    # line[0] = 'H', line[1] = source, line[2:5] = TLC
    tlc = line[2:5]
    rest = line[5:]

    # Newer format: LONG_NAME:VALUE
    colon_pos = rest.find(":")
    if colon_pos != -1:
        value = rest[colon_pos + 1 :]
    else:
        # Legacy format: value starts immediately after TLC
        value = rest

    return tlc, value.strip()


def _nil_to_none(value: str) -> str | None:
    """Return *None* if value is ``NIL`` (case-insensitive), else the value."""
    return None if value.upper() == "NIL" else value


def _parse_igc_file(
    igc_path: Path,
) -> tuple[
    str | None, dict[str, str], list[tuple[int, int, str]], list[dict[str, Any]]
]:
    """Single-pass parse of an IGC file.

    Returns
    -------
    fr_id : str | None
        Flight-recorder ID from the A record.
    h_records : dict[str, str]
        TLC → raw value from all H records.
    i_extensions : list[tuple[int, int, str]]
        I-record extension definitions as ``(start_byte, end_byte, TLC)``
        with 1-based byte positions.
    b_fixes : list[dict[str, Any]]
        Parsed B-record fixes, each containing ``time_s``, ``lat``, ``lon``,
        ``alt_baro``, ``alt_gps``, ``validity``, and ``datetime``.
    """
    text = igc_path.read_text(encoding="latin-1")
    lines = text.splitlines()

    fr_id: str | None = None
    h_records: dict[str, str] = {}
    i_extensions: list[tuple[int, int, str]] = []
    b_fixes: list[dict[str, Any]] = []

    flight_date: date | None = None
    prev_time_s: int | None = None  # previous B-record time-of-day in seconds
    day_offset_days: int = 0  # midnight rollover counter

    for line in lines:
        if not line:
            continue
        rec_type = line[0]

        # --- A record: flight recorder ID ---
        if rec_type == "A":
            fr_id = line[1:].strip()

        # --- H record: header metadata ---
        elif rec_type == "H":
            tlc, value = _parse_h_record(line)
            h_records[tlc] = value

            # Parse date eagerly so B-record parsing can use it
            if tlc == "DTE":
                flight_date = _parse_hfdte(value)

        # --- I record: B-record extension definitions ---
        elif rec_type == "I":
            # Format: I NN SS EE TLC SS EE TLC ...
            # NN = number of extensions (2 digits)
            num_ext = int(line[1:3])
            for i in range(num_ext):
                offset = 3 + i * 7
                start = int(line[offset : offset + 2])
                end = int(line[offset + 2 : offset + 4])
                tlc = line[offset + 4 : offset + 7]
                i_extensions.append((start, end, tlc))

        # --- B record: fix ---
        elif rec_type == "B" and len(line) >= 35:
            hh = int(line[1:3])
            mm = int(line[3:5])
            ss = int(line[5:7])
            time_of_day_s = hh * 3600 + mm * 60 + ss

            # Midnight rollover detection
            if prev_time_s is not None and time_of_day_s < prev_time_s - 3600:
                # Large backward jump → crossed midnight
                day_offset_days += 1
            prev_time_s = time_of_day_s

            total_seconds = day_offset_days * 86400 + time_of_day_s

            lat = _parse_igc_latitude(line[7:15])
            lon = _parse_igc_longitude(line[15:24])
            validity = line[24]
            alt_baro = int(line[25:30])
            alt_gps = int(line[30:35])

            # Build absolute datetime if flight_date is known
            fix_dt: datetime | None = None
            if flight_date is not None:
                fix_dt = datetime(
                    flight_date.year,
                    flight_date.month,
                    flight_date.day,
                    tzinfo=timezone.utc,
                ) + timedelta(days=day_offset_days, seconds=time_of_day_s)

            b_fixes.append(
                {
                    "total_seconds": total_seconds,
                    "lat": lat,
                    "lon": lon,
                    "alt_baro": alt_baro,
                    "alt_gps": alt_gps,
                    "validity": validity,
                    "datetime": fix_dt,
                }
            )

    return fr_id, h_records, i_extensions, b_fixes


def _build_trajectory_df(b_fixes: list[dict[str, Any]]) -> pd.DataFrame:
    """Build the 1 Hz trajectory DataFrame from parsed B-record fixes."""
    if not b_fixes:
        return pd.DataFrame()

    first_ts = b_fixes[0]["total_seconds"]

    rows = []
    for fix in b_fixes:
        rows.append(
            {
                "timestamp_s": float(fix["total_seconds"] - first_ts),
                "gps_lat_deg": fix["lat"],
                "gps_lon_deg": fix["lon"],
                "alt_baro_m": fix["alt_baro"],
                "alt_gps_m": fix["alt_gps"],
                "fix_validity": fix["validity"],
            }
        )

    return pd.DataFrame(rows)


def _build_metadata(
    fr_id: str | None,
    h_records: dict[str, str],
    b_fixes: list[dict[str, Any]],
) -> dict[str, Any]:
    """Build the metadata dictionary from parsed IGC data."""

    # --- Date ---
    dte_raw = h_records.get("DTE")
    flight_date: date | None = None
    if dte_raw is not None:
        flight_date = _parse_hfdte(dte_raw)
    date_str = flight_date.isoformat() if flight_date is not None else None

    # --- Derived from B records ---
    gps_start_utc: str | None = None
    duration_s: float | None = None
    num_fixes = len(b_fixes)

    if b_fixes:
        first_fix = b_fixes[0]
        last_fix = b_fixes[-1]
        duration_s = float(last_fix["total_seconds"] - first_fix["total_seconds"])

        if first_fix["datetime"] is not None:
            gps_start_utc = first_fix["datetime"].strftime("%Y-%m-%dT%H:%M:%SZ")

    # --- H-record fields ---
    def _h(tlc: str) -> str | None:
        """Return the raw H-record value, or *None* if the TLC is absent."""
        return h_records.get(tlc)

    def _h_nil(tlc: str) -> str | None:
        """Return *None* when the value is ``NIL``; used for person fields."""
        val = h_records.get(tlc)
        if val is None:
            return None
        return _nil_to_none(val)

    # Timezone needs numeric conversion
    tzn_raw = h_records.get("TZN")
    timezone_offset_h: float | None = None
    if tzn_raw is not None and tzn_raw.upper() != "NIL":
        try:
            timezone_offset_h = float(tzn_raw)
        except ValueError:
            timezone_offset_h = None

    meta: dict[str, Any] = {
        "date": date_str,
        "gps_start_utc": gps_start_utc,
        "duration_s": duration_s,
        "num_fixes": num_fixes,
        "pilot": _h_nil("PLT"),
        "copilot": _h_nil("CM2"),
        "glider_type": _h("GTY"),
        "glider_id": _h("GID"),
        "competition_id": _h("CID"),
        "competition_class": _h("CCL"),
        "fr_type": _h("FTY"),
        "firmware": _h("RFW"),
        "hardware": _h("RHW"),
        "gps_receiver": _h("GPS"),
        "pressure_sensor": _h("PRS"),
        "gps_datum": _h("DTM"),
        "altitude_gps_ref": _h("ALG"),
        "altitude_pressure_ref": _h("ALP"),
        "timezone_offset_h": timezone_offset_h,
        "fr_id": fr_id,
    }

    return meta


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def extract_igc_telemetry(flight_data: FlightData) -> FlightData:
    """Extract trajectory CSV and metadata JSON from an IGC file.

    Parameters
    ----------
    flight_data:
        A :class:`FlightData` instance whose ``igc_telemetry.igc_path``
        points to the source ``.igc`` file.

    Returns
    -------
    FlightData
        A copy of *flight_data* with ``igc_telemetry.trajectory``,
        ``igc_telemetry.metadata``, and ``igc_telemetry.origin``
        populated.  ``origin`` is set to the WGS 84 coordinates
        (lat, lon, GPS altitude) of the first recorded B-record fix.
    """
    if flight_data.igc_telemetry is None:
        raise ValueError(
            "FlightData object does not have a valid igc_telemetry field. "
            "Use find_data_sources first."
        )

    if flight_data.igc_telemetry.igc_path is None:
        raise ValueError(
            "FlightData object does not have a valid igc_telemetry.igc_path field. "
            "Use find_data_sources first."
        )

    igc_path = flight_data.igc_telemetry.igc_path

    if flight_data.flight_tag is None:
        raise ValueError(
            "FlightData object does not have a valid flight_tag field. "
            "Use find_data_sources first."
        )

    flight_tag = flight_data.flight_tag

    igc_size_kb = igc_path.stat().st_size / 1024
    logger.info(
        "Extracting IGC telemetry from %s (%.1f KiB)",
        igc_path.name,
        igc_size_kb,
    )
    t_total = time.monotonic()

    # ------------------------------------------------------------------
    # Parse
    # ------------------------------------------------------------------
    fr_id, h_records, i_extensions, b_fixes = _parse_igc_file(igc_path)

    if not b_fixes:
        logger.warning("No B-record fixes found in %s", igc_path.name)
        return flight_data.model_copy()

    logger.info(
        "Parsed %d B-record fixes (I-extensions: %d, H-records: %d)",
        len(b_fixes),
        len(i_extensions),
        len(h_records),
    )

    output_dir: Path = config.DIR.TELEMETRY
    output_dir.mkdir(parents=True, exist_ok=True)

    igc_telemetry: IGCTelemetry = flight_data.igc_telemetry.model_copy()
    extracted_files = 0

    # ------------------------------------------------------------------
    # Origin — WGS 84 coordinates of the first recorded fix
    # ------------------------------------------------------------------
    first_fix = b_fixes[0]
    igc_telemetry.origin = WGS84Coordinate(
        lat=first_fix["lat"],
        lon=first_fix["lon"],
        alt=first_fix["alt_gps"],
    )
    logger.info(
        "  Origin (WGS 84):  lat=%.6f  lon=%.6f  alt=%.0f m",
        igc_telemetry.origin.lat,
        igc_telemetry.origin.lon,
        igc_telemetry.origin.alt,
    )

    # ------------------------------------------------------------------
    # Flight metadata JSON
    # ------------------------------------------------------------------
    meta = _build_metadata(fr_id, h_records, b_fixes)

    meta_json = output_dir / f"{flight_tag}_igc_meta.json"
    meta_json.write_text(json.dumps(meta, indent=2) + "\n")
    logger.info("Wrote metadata:     %s", meta_json.name)

    if meta.get("gps_start_utc") is not None:
        logger.info("  GPS start (UTC):  %s", meta["gps_start_utc"])
    if meta.get("pilot") is not None:
        logger.info("  Pilot:            %s", meta["pilot"])
    if meta.get("glider_type") is not None:
        logger.info(
            "  Glider:           %s (%s)",
            meta["glider_type"],
            meta.get("glider_id") or "?",
        )
    if meta.get("fr_type") is not None:
        logger.info("  Recorder:         %s", meta["fr_type"])
    if meta.get("pressure_sensor") is not None:
        logger.info("  Pressure sensor:  %s", meta["pressure_sensor"])
    else:
        logger.info("  Pressure sensor:  NIL (not available)")

    igc_telemetry.metadata = meta_json
    extracted_files += 1

    # ------------------------------------------------------------------
    # 1 Hz trajectory CSV
    # ------------------------------------------------------------------
    traj_df = _build_trajectory_df(b_fixes)

    if not traj_df.empty:
        traj_csv = output_dir / f"{flight_tag}_igc.csv"
        traj_df.to_csv(traj_csv, index=False)
        csv_size_kb = traj_csv.stat().st_size / 1024
        ts = traj_df["timestamp_s"]
        span = ts.iloc[-1] - ts.iloc[0]
        logger.info(
            "Wrote IGC CSV:      %s  (%d rows, %.1f s, %.0f KiB)",
            traj_csv.name,
            len(traj_df),
            span,
            csv_size_kb,
        )

        # Fix validity summary
        fix_counts = traj_df["fix_validity"].value_counts().to_dict()
        logger.info(
            "  Fix validity: %s  |  lat: %.4f – %.4f  |  lon: %.4f – %.4f",
            ", ".join(f"{k}={int(v)}" for k, v in sorted(fix_counts.items())),
            traj_df["gps_lat_deg"].min(),
            traj_df["gps_lat_deg"].max(),
            traj_df["gps_lon_deg"].min(),
            traj_df["gps_lon_deg"].max(),
        )
        logger.info(
            "  alt_baro: %.0f – %.0f m  |  alt_gps: %.0f – %.0f m",
            traj_df["alt_baro_m"].min(),
            traj_df["alt_baro_m"].max(),
            traj_df["alt_gps_m"].min(),
            traj_df["alt_gps_m"].max(),
        )

        igc_telemetry.trajectory = traj_csv
        extracted_files += 1
    else:
        logger.warning("No B-record data found — skipping trajectory CSV")

    elapsed = time.monotonic() - t_total
    logger.info("Extraction complete — %d files in %.2f s", extracted_files, elapsed)

    return flight_data.model_copy(
        update={
            "igc_telemetry": igc_telemetry,
        }
    )
